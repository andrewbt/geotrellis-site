{"body": "<div class=\"section\" id=\"spray-client\">\n<span id=\"id1\"></span><h1>spray-client</h1>\n<p><em>spray-client</em> provides high-level HTTP client functionality by adding another logic layer on top of the rather\nlow-level <a class=\"reference internal\" href=\"../spray-can/http-client/#httpclient\"><em>HttpClient</em></a> that is part of the <a class=\"reference internal\" href=\"../spray-can/#spray-can\"><em>spray-can</em></a> module. It sports the following features:</p>\n<ul class=\"simple\">\n<li>Connection pooling</li>\n<li>Rich, immutable HTTP model</li>\n<li>Compression / Decompression</li>\n<li>Marshalling / Unmarshalling from and to your custom types</li>\n<li>HTTP Basic Auth</li>\n<li>Configurable retry behavior</li>\n<li>Full support for HTTP pipelining</li>\n<li>Actor-based architecture for easy integration into your Akka applications</li>\n</ul>\n<p>Currently, HTTP streaming (i.e. chunked transfer encoding) is not yet fully supported on the <em>spray-client</em> level\n(even though the underlying <em>spray-can</em> <a class=\"reference internal\" href=\"../spray-can/http-client/#httpclient\"><em>HttpClient</em></a> does support it), i.e. you cannot send chunked requests and\nthe <tt class=\"docutils literal\"><span class=\"pre\">spray.can.client.response-chunk-aggregation-limit</span></tt> config setting must be non-zero).</p>\n<div class=\"section\" id=\"dependencies\">\n<h2>Dependencies</h2>\n<p>Apart from the Scala library (see <a class=\"reference internal\" href=\"../../project-info/current-versions/#current-versions\"><em>Current Version(s)</em></a> chapter) <em>spray-client</em> depends on</p>\n<ul class=\"simple\">\n<li><a class=\"reference internal\" href=\"../spray-can/#spray-can\"><em>spray-can</em></a></li>\n<li><a class=\"reference internal\" href=\"../spray-http/#spray-http\"><em>spray-http</em></a></li>\n<li><a class=\"reference internal\" href=\"../spray-httpx/#spray-httpx\"><em>spray-httpx</em></a></li>\n<li><a class=\"reference internal\" href=\"../spray-util/#spray-util\"><em>spray-util</em></a></li>\n<li>akka-actor (with &#8216;provided&#8217; scope, i.e. you need to pull it in yourself)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"installation\">\n<h2>Installation</h2>\n<p>The <a class=\"reference internal\" href=\"../../project-info/maven-repository/#maven-repo\"><em>Maven Repository</em></a> chapter contains all the info about how to pull <em>spray-client</em> into your classpath.</p>\n<p>Afterwards just <tt class=\"docutils literal\"><span class=\"pre\">import</span> <span class=\"pre\">spray.client._</span></tt> to bring all relevant identifiers into scope.</p>\n</div>\n<div class=\"section\" id=\"configuration\">\n<h2>Configuration</h2>\n<p>Just like Akka <em>spray-client</em> relies on the <a class=\"reference external\" href=\"https://github.com/typesafehub/config\">typesafe config</a> library for configuration. As such its JAR contains a\n<tt class=\"docutils literal\"><span class=\"pre\">reference.conf</span></tt> file holding the default values of all configuration settings. In your application you typically\nprovide an <tt class=\"docutils literal\"><span class=\"pre\">application.conf</span></tt>, in which you override Akka and/or <em>spray</em> settings according to your needs.</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">Since <em>spray</em> uses the same configuration technique as Akka you might want to check out the\n<a class=\"reference external\" href=\"http://doc.akka.io/docs/akka/2.0.4/general/configuration.html\">Akka Documentation on Configuration</a>.</p>\n</div>\n<p>This is the <tt class=\"docutils literal\"><span class=\"pre\">reference.conf</span></tt> of the <em>spray-client</em> module:</p>\n<div class=\"highlight-bash\"><div class=\"highlight\"><pre><span class=\"c\">######################################</span>\n<span class=\"c\"># spray-client Reference Config File #</span>\n<span class=\"c\">######################################</span>\n\n<span class=\"c\"># This is the reference config file that contains all the default settings.</span>\n<span class=\"c\"># Make your edits/overrides in your application.conf.</span>\n\nspray.client <span class=\"o\">{</span>\n  <span class=\"c\"># the maximum number of parallel connections that an HttpConduit</span>\n  <span class=\"c\"># is allowed to establish to a host, must be greater than zero</span>\n  max-connections <span class=\"o\">=</span> 4\n\n  <span class=\"c\"># the maximum number of retries an HttpConduit will attempt before</span>\n  <span class=\"c\"># giving up and returning an error</span>\n  max-retries <span class=\"o\">=</span> 5\n\n  <span class=\"c\"># if this setting is enabled, the HttpConduit will log warnings for</span>\n  <span class=\"c\"># all illegal response headers coming back from a target server</span>\n  warn-on-illegal-headers <span class=\"o\">=</span> on\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"basic-usage\">\n<h2>Basic Usage</h2>\n<p>The central element in <em>spray-client</em> is the <tt class=\"docutils literal\"><span class=\"pre\">HttpConduit</span></tt>, which is an abstraction over a number of HTTP connections\nto <em>one</em> specific HTTP server (the underlying <em>spray-can</em> <a class=\"reference internal\" href=\"../spray-can/http-client/#httpclient\"><em>HttpClient</em></a> works on the level of one single HTTP\nconnection). An <tt class=\"docutils literal\"><span class=\"pre\">HttpConduit</span></tt> can be reused for all requests to a specific host that an application would like to\nfire, but it cannot be &#8220;re-targeted&#8221; to a different host. However, since an <tt class=\"docutils literal\"><span class=\"pre\">HttpConduit</span></tt> is light-weight you can\nsimply create a new instance for every new target server the application needs to talk to.</p>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">HttpConduit</span></tt> is a regular actor, so you create one like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">scala.concurrent.Future</span>\n<span class=\"k\">import</span> <span class=\"nn\">akka.actor._</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.can.client.HttpClient</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.client.HttpConduit</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.io._</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.util._</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.http._</span>\n<span class=\"k\">import</span> <span class=\"nn\">HttpMethods._</span>\n\n<span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">system</span> <span class=\"k\">=</span> <span class=\"nc\">ActorSystem</span><span class=\"o\">()</span>\n<span class=\"k\">val</span> <span class=\"n\">ioBridge</span> <span class=\"k\">=</span> <span class=\"nc\">IOExtension</span><span class=\"o\">(</span><span class=\"n\">system</span><span class=\"o\">).</span><span class=\"n\">ioBridge</span><span class=\"o\">()</span>\n<span class=\"k\">val</span> <span class=\"n\">httpClient</span> <span class=\"k\">=</span> <span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">actorOf</span><span class=\"o\">(</span><span class=\"nc\">Props</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">HttpClient</span><span class=\"o\">(</span><span class=\"n\">ioBridge</span><span class=\"o\">)))</span>\n\n<span class=\"k\">val</span> <span class=\"n\">conduit</span> <span class=\"k\">=</span> <span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">actorOf</span><span class=\"o\">(</span>\n  <span class=\"n\">props</span> <span class=\"k\">=</span> <span class=\"nc\">Props</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">HttpConduit</span><span class=\"o\">(</span><span class=\"n\">httpClient</span><span class=\"o\">,</span> <span class=\"n\">targetHostName</span><span class=\"o\">,</span> <span class=\"n\">port</span><span class=\"o\">)),</span>\n  <span class=\"n\">name</span> <span class=\"k\">=</span> <span class=\"s\">&quot;http-conduit&quot;</span>\n<span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>Once you have a reference to a conduit you typically create a &#8220;pipeline&#8221; around it. In the simplest case this looks like\nthis:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">pipeline</span> <span class=\"k\">=</span> <span class=\"nc\">HttpConduit</span><span class=\"o\">.</span><span class=\"n\">sendReceive</span><span class=\"o\">(</span><span class=\"n\">conduit</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>In this case the pipeline has the type <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span> <span class=\"pre\">=&gt;</span> <span class=\"pre\">Future[Response]</span></tt>, so you can use it like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">response</span><span class=\"k\">:</span> <span class=\"kt\">Future</span><span class=\"o\">[</span><span class=\"kt\">HttpResponse</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"n\">pipeline</span><span class=\"o\">(</span><span class=\"nc\">HttpRequest</span><span class=\"o\">(</span><span class=\"n\">method</span> <span class=\"k\">=</span> <span class=\"nc\">GET</span><span class=\"o\">,</span> <span class=\"n\">uri</span> <span class=\"k\">=</span> <span class=\"s\">&quot;/&quot;</span><span class=\"o\">))</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"message-pipeline\">\n<h2>Message Pipeline</h2>\n<p>A pipeline of type <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span> <span class=\"pre\">=&gt;</span> <span class=\"pre\">Future[HttpResponse]</span></tt> is nice start but leaves the creation of requests and\ninterpretation of responses completely to you. Many times you actually want to send and/or receive custom objects that\nneed to be serialized to HTTP requests or deserialized from HTTP responses. <em>spray-client</em> supports this via the\nconcept of a &#8220;Message Pipeline&#8221;.</p>\n<p>Check out this snippet:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">spray.httpx.encoding.</span><span class=\"o\">{</span><span class=\"nc\">Gzip</span><span class=\"o\">,</span> <span class=\"nc\">Deflate</span><span class=\"o\">}</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.httpx.SprayJsonSupport._</span>\n\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">Order</span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"k\">:</span> <span class=\"kt\">Int</span><span class=\"o\">)</span>\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">OrderConfirmation</span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"k\">:</span> <span class=\"kt\">Int</span><span class=\"o\">)</span>\n\n<span class=\"k\">object</span> <span class=\"nc\">MyJsonProtocol</span> <span class=\"k\">extends</span> <span class=\"nc\">DefaultJsonProtocol</span> <span class=\"o\">{</span>\n  <span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">orderFormat</span> <span class=\"k\">=</span> <span class=\"n\">jsonFormat1</span><span class=\"o\">(</span><span class=\"nc\">Order</span><span class=\"o\">)</span>\n  <span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">orderConfirmationFormat</span> <span class=\"k\">=</span> <span class=\"n\">jsonFormat1</span><span class=\"o\">(</span><span class=\"nc\">OrderConfirmation</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">import</span> <span class=\"nn\">HttpConduit._</span>\n<span class=\"k\">import</span> <span class=\"nn\">MyJsonProtocol._</span>\n\n<span class=\"k\">val</span> <span class=\"n\">pipeline</span><span class=\"k\">:</span> <span class=\"kt\">HttpRequest</span> <span class=\"o\">=&gt;</span> <span class=\"nc\">Future</span><span class=\"o\">[</span><span class=\"kt\">OrderConfirmation</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"o\">(</span>\n  <span class=\"n\">addHeader</span><span class=\"o\">(</span><span class=\"s\">&quot;X-My-Special-Header&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;fancy-value&quot;</span><span class=\"o\">)</span>\n  <span class=\"o\">~&gt;</span> <span class=\"n\">addCredentials</span><span class=\"o\">(</span><span class=\"nc\">BasicHttpCredentials</span><span class=\"o\">(</span><span class=\"s\">&quot;bob&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;secret&quot;</span><span class=\"o\">))</span>\n  <span class=\"o\">~&gt;</span> <span class=\"n\">encode</span><span class=\"o\">(</span><span class=\"nc\">Gzip</span><span class=\"o\">)</span>\n  <span class=\"o\">~&gt;</span> <span class=\"n\">sendReceive</span><span class=\"o\">(</span><span class=\"n\">conduit</span><span class=\"o\">)</span>\n  <span class=\"o\">~&gt;</span> <span class=\"n\">decode</span><span class=\"o\">(</span><span class=\"nc\">Deflate</span><span class=\"o\">)</span>\n  <span class=\"o\">~&gt;</span> <span class=\"n\">unmarshal</span><span class=\"o\">[</span><span class=\"kt\">OrderConfirmation</span><span class=\"o\">]</span>\n<span class=\"o\">)</span>\n<span class=\"k\">val</span> <span class=\"n\">confirmation</span><span class=\"k\">:</span> <span class=\"kt\">Future</span><span class=\"o\">[</span><span class=\"kt\">OrderConfirmation</span><span class=\"o\">]</span> <span class=\"k\">=</span>\n  <span class=\"n\">pipeline</span><span class=\"o\">(</span><span class=\"nc\">Post</span><span class=\"o\">(</span><span class=\"s\">&quot;/orders&quot;</span><span class=\"o\">,</span> <span class=\"nc\">Order</span><span class=\"o\">(</span><span class=\"mi\">42</span><span class=\"o\">)))</span>\n</pre></div>\n</div>\n<p>This defines a more complex pipeline that takes an <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt>, adds headers and compresses its entity before\ndispatching it to the target server (the <tt class=\"docutils literal\"><span class=\"pre\">sendReceive</span></tt> element of the pipeline). The response coming back is then\ndecompressed and its entity unmarshalled.</p>\n<p>If you <tt class=\"docutils literal\"><span class=\"pre\">import</span> <span class=\"pre\">HttpConduit._</span></tt> you not only get easy access to <tt class=\"docutils literal\"><span class=\"pre\">sendReceive</span></tt> but also all elements of the\n<a class=\"reference internal\" href=\"../spray-httpx/request-building/#requestbuilding\"><em>Request Building</em></a> trait, which is mixed in by the <tt class=\"docutils literal\"><span class=\"pre\">HttpConduit</span></tt> companion object. Therefore you can easily create\nrequests via something like <tt class=\"docutils literal\"><span class=\"pre\">Post(&quot;/orders&quot;,</span> <span class=\"pre\">Order(42))</span></tt>, which is not only shorter but also provides for\nautomatic marshalling of custom types.</p>\n</div>\n<div class=\"section\" id=\"dispatch-strategy\">\n<h2>Dispatch Strategy</h2>\n<p>Apart from the underlying <a class=\"reference internal\" href=\"../spray-can/http-client/#httpclient\"><em>HttpClient</em></a> instance to use and the target servers hostname/port the <tt class=\"docutils literal\"><span class=\"pre\">HttpConduit</span></tt>\nconstructor takes a <tt class=\"docutils literal\"><span class=\"pre\">DispatchStrategy</span></tt> instance (with <tt class=\"docutils literal\"><span class=\"pre\">NonPipelined</span></tt> being the default).\nA <tt class=\"docutils literal\"><span class=\"pre\">DispatchStrategy</span></tt> determines how outgoing requests are scheduled across the several connections the conduit\nmanages. Currently <em>spray-client</em> comes with two predefined strategies, which schedule requests across connections\nvia the following logic:</p>\n<dl class=\"docutils\">\n<dt>NonPipelined (default)</dt>\n<dd><ul class=\"first last simple\">\n<li>Dispatch to the first idle connection in the pool, if there is one.</li>\n<li>If none is idle, dispatch to the first unconnected connection, if there is one.</li>\n<li>If all are already connected, store the request and send it as soon as one\nconnection becomes either idle or unconnected.</li>\n</ul>\n</dd>\n<dt>Pipelined</dt>\n<dd><ul class=\"first last simple\">\n<li>Dispatch to the first idle connection in the pool, if there is one.</li>\n<li>If none is idle, dispatch to the first unconnected connection, if there is one.</li>\n<li>If all are already connected, dispatch to the connection with the least open requests.</li>\n</ul>\n</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"error-handling\">\n<h2>Error Handling</h2>\n<p>In case of errors an <tt class=\"docutils literal\"><span class=\"pre\">HttpConduit</span></tt> will retry requests up to the number of times configured as <tt class=\"docutils literal\"><span class=\"pre\">max-retries</span></tt>, before\ncompleting the response future with an exception.</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">Only idempotent requests, as defined by the HTTP spec, are retried. Requests with HTTP methods <tt class=\"docutils literal\"><span class=\"pre\">POST</span></tt> or\n<tt class=\"docutils literal\"><span class=\"pre\">PATCH</span></tt> are not considered idempotent and therefore <em>never</em> retried.</p>\n</div>\n</div>\n<div class=\"section\" id=\"example\">\n<h2>Example</h2>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">/examples/spray-client/</span></tt> directory of the <em>spray</em> repository\ncontains a number of example projects for <em>spray-client</em>.</p>\n<div class=\"section\" id=\"simple-spray-client\">\n<h3>simple-spray-client</h3>\n<p>This example shows off how to use <em>spray-client</em> by performing two things</p>\n<ul class=\"simple\">\n<li>fetch the github homepage (a very simple GET)</li>\n<li>query the Googles Elevation API to retrieve the elevation of Mt. Everest</li>\n</ul>\n<p>Follow these steps to run it on your machine:</p>\n<ol class=\"arabic\">\n<li><p class=\"first\">Clone the <em>spray</em> repository:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"n\">git</span> <span class=\"n\">clone</span> <span class=\"n\">git</span><span class=\"o\">://</span><span class=\"n\">github</span><span class=\"o\">.</span><span class=\"n\">com</span><span class=\"o\">/</span><span class=\"n\">spray</span><span class=\"o\">/</span><span class=\"n\">spray</span><span class=\"o\">.</span><span class=\"n\">git</span>\n</pre></div>\n</div>\n</li>\n<li><p class=\"first\">Change into the base directory:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"n\">cd</span> <span class=\"n\">spray</span>\n</pre></div>\n</div>\n</li>\n<li><p class=\"first\">Run SBT:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"n\">sbt</span> <span class=\"s\">&quot;project simple-spray-client&quot;</span> <span class=\"n\">run</span>\n</pre></div>\n</div>\n<p>(If this doesn&#8217;t work for you your SBT runner cannot deal with grouped arguments. In this case you&#8217;ll have to\nrun the commands <tt class=\"docutils literal\"><span class=\"pre\">project</span> <span class=\"pre\">simple-spray-client</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">run</span></tt> sequentially &#8220;inside&#8221; of SBT.)</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n", "display_toc": true, "title": "spray-client", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-client/index", "next": {"link": "../spray-http/", "title": "spray-http"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-http/index", "spray-http", "N", "next"], ["documentation/spray-can/examples", "Examples", "P", "previous"]], "meta": {}, "parents": [{"link": "../", "title": "Documentation"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">spray-client</a><ul>\n<li><a class=\"reference internal\" href=\"#dependencies\">Dependencies</a></li>\n<li><a class=\"reference internal\" href=\"#installation\">Installation</a></li>\n<li><a class=\"reference internal\" href=\"#configuration\">Configuration</a></li>\n<li><a class=\"reference internal\" href=\"#basic-usage\">Basic Usage</a></li>\n<li><a class=\"reference internal\" href=\"#message-pipeline\">Message Pipeline</a></li>\n<li><a class=\"reference internal\" href=\"#dispatch-strategy\">Dispatch Strategy</a></li>\n<li><a class=\"reference internal\" href=\"#error-handling\">Error Handling</a></li>\n<li><a class=\"reference internal\" href=\"#example\">Example</a><ul>\n<li><a class=\"reference internal\" href=\"#simple-spray-client\">simple-spray-client</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../spray-can/examples/", "title": "Examples"}, "metatags": ""}